#include "main.h"
#include "app_flash.h"

#if 0

// #2
float cxxx0[4] = {48.421955, 47.353771 ,47.080742, 46.285637};
float cxxx1[4] = {49.012707, 48.329891 ,47.491074, 48.256878};
float cxxx2[4] = {47.831585, 46.743111 ,45.894424, 46.040894};
float cxxx3[4] = {48.458073, 47.082443 ,46.404686, 47.370571};

// #3
float cxxx0[4] = {49.085854, 46.754391 ,47.305668, 47.617855};
float cxxx1[4] = {49.390076, 47.214165 ,47.580078, 47.550770};
float cxxx2[4] = {48.645668, 46.924694 ,46.553848, 46.261055};
float cxxx3[4] = {48.961124, 46.502979 ,46.702702, 46.692841};

// #4
float cxxx0[4] = {47.467991, 46.980145 ,46.511971, 46.643604};
float cxxx1[4] = {48.774639, 47.657879 ,47.979839, 47.565258};
float cxxx2[4] = {47.963493, 47.167912 ,46.256557, 47.114960};
float cxxx3[4] = {49.648136, 47.301777 ,47.872406, 47.911308};

// #5
float cxxx0[4] = {48.466778, 47.759884 ,47.833157, 47.427864};
float cxxx1[4] = {47.743050, 47.806694 ,47.440479, 48.026127};
float cxxx2[4] = {48.593426, 47.428055 ,47.261429, 46.900677};
float cxxx3[4] = {49.418274, 48.198513 ,47.452339, 47.139942};

// #6
float cxxx0[4] = {47.881008, 45.832191 ,45.788857, 46.818199};
float cxxx1[4] = {49.331783, 47.824814 ,47.590790, 47.766464};
float cxxx2[4] = {49.313919, 47.371807 ,47.522858, 48.016975};
float cxxx3[4] = {47.932426, 47.185936 ,46.805271, 46.995625};

// #7
float cxxx0[4] = {47.972610, 47.186901 ,46.479725, 44.060085};
float cxxx1[4] = {49.164906, 47.316345 ,47.657944, 47.462620};
float cxxx2[4] = {47.145576, 46.052933 ,45.715851, 46.257778};
float cxxx3[4] = {46.593060, 45.925716 ,46.818619, 46.632576};

// #8
float cxxx0[4] = {49.540291, 47.535648 ,46.540569, 47.959827};
float cxxx1[4] = {48.666500, 48.363800 ,48.270828, 48.041985};
float cxxx2[4] = {48.485256, 46.889961 ,48.041031, 47.265648};
float cxxx3[4] = {49.127579, 48.103046 ,47.405479, 48.054623};

// #1
float cxxx0[4] = {48.316586, 46.609501 ,46.633343, 46.921551};
float cxxx1[4] = {47.762135, 46.723316 ,46.034943, 46.376556};
float cxxx2[4] = {48.416630, 47.660492 ,47.484470, 47.226276};
float cxxx3[4] = {48.783554, 47.140003 ,47.847862, 47.711185};
#endif
// #9
float cxxx0[4] = {48.488205, 47.234386, 47.517384, 47.321560};
float cxxx1[4] = {48.708118, 48.245430, 46.938305, 47.723248};
float cxxx2[4] = {47.610901, 45.718662, 45.791687, 46.089081};
float cxxx3[4] = {48.044056, 46.619381, 46.000000, 46.590115};
#if 0
// #10
float cxxx0[4] = {48.728149, 47.709522 ,47.582222, 47.655609};
float cxxx1[4] = {49.357426, 48.040771 ,47.405712, 48.015965};
float cxxx2[4] = {48.202126, 47.143486 ,47.060635, 47.343895};
float cxxx3[4] = {47.214783, 46.902737 ,46.897747, 46.180393};

// #11
float cxxx0[4] = {48.579807, 47.486809 ,47.764729, 47.404781};
float cxxx1[4] = {48.873756, 46.796261 ,47.132378, 47.069103};
float cxxx2[4] = {47.397301, 46.768009 ,46.397106, 46.114159};
float cxxx3[4] = {48.912090, 47.385731 ,47.335365, 47.794315};

// #12
float cxxx0[4] = {48.959797, 48.028595 ,47.053276, 47.599503};
float cxxx1[4] = {48.476334, 47.262085 ,46.589005, 46.266788};
float cxxx2[4] = {48.838009, 47.896816 ,47.345871, 47.481358};
float cxxx3[4] = {49.063976, 47.747566 ,47.855000, 46.844822};

// #13
float cxxx0[4] = {47.917580, 46.111389 ,46.901314, 46.706379};
float cxxx1[4] = {46.704342, 45.737854 ,46.142994, 45.913700};
float cxxx2[4] = {48.538609, 46.616436 ,46.670307, 47.206772};
float cxxx3[4] = {49.471718, 47.427853 ,47.476818, 47.969185};

// #14
float cxxx0[4] = {48.844177, 47.766815 ,47.185730, 47.078274};
float cxxx1[4] = {49.144123, 47.393219 ,47.412708, 47.461601};
float cxxx2[4] = {47.760933, 47.189667 ,46.736115, 46.458111};
float cxxx3[4] = {48.623039, 47.408344 ,47.759724, 47.867306};

// #15
float cxxx0[4] = {48.284462, 47.147770 ,47.084740, 46.426121};
float cxxx1[4] = {48.235546, 46.396698 ,46.664757, 47.694584};
float cxxx2[4] = {47.878815, 46.961678 ,47.078945, 47.995728};
float cxxx3[4] = {49.608334, 47.857700 ,47.305870, 47.949780};

// #16
float cxxx0[4] = {47.694180, 47.045406 ,47.079582, 46.929165};
float cxxx1[4] = {48.873581, 47.196815 ,47.090038, 47.953438};
float cxxx2[4] = {48.891060, 47.555332 ,47.355324, 47.198612};
float cxxx3[4] = {48.574257, 46.740639 ,46.501339, 47.398743};

// #17
float cxxx0[4] = {46.366093, 44.834419 ,45.902210, 42.346344};
float cxxx1[4] = {49.032887, 47.813766 ,46.964714, 46.540783};
float cxxx2[4] = {48.262943, 47.179863 ,46.712574, 47.004639};
float cxxx3[4] = {49.400478, 47.737492 ,46.805611, 47.737335};

// #18
float cxxx0[4] = {48.584724, 48.037868 ,47.388992, 47.530727};
float cxxx1[4] = {48.192715, 45.885464 ,47.080597, 46.456398};
float cxxx2[4] = {47.964443, 46.232544 ,45.944527, 46.671562};
float cxxx3[4] = {49.165737, 47.638958 ,48.004807, 47.990314};

// #19
float cxxx0[4] = {49.033237, 47.063328 ,47.448605, 46.858765};
float cxxx1[4] = {49.148994, 47.041817 ,47.963299, 48.080479};
float cxxx2[4] = {49.284840, 47.841064 ,47.821785, 47.401939};
float cxxx3[4] = {48.654419, 47.078800 ,46.249519, 46.981365};

// #20
float cxxx0[4] = {48.821301, 47.094875 ,47.431355, 47.431831};
float cxxx1[4] = {48.148201, 45.986477 ,47.001400, 46.894291};
float cxxx2[4] = {49.371532, 47.025318 ,47.893623, 47.601223};
float cxxx3[4] = {48.405056, 46.672997 ,45.946342, 46.561134};

#endif

// extern float coe_buffer[16];          // 归一化系数
extern IWDG_HandleTypeDef IwdgHandle; // 看门狗句柄
uint8_t send_once_flag = 1;           // 用于11命令只保存一次状态
uint8_t channel_map[6] = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0};

// uint32_t test_data[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};

#if 0
int main(void)
{
    // HAL库初始化
    HAL_Init();

    // 系统时钟初始化
    System_Clock_Config_HSI_24Mhz();

    // 看门狗初始化
    IwdgHandle.Instance = IWDG;                     // 独立看门狗的基地址
    IwdgHandle.Init.Prescaler = IWDG_PRESCALER_256; // 使用最大分频系数256
    IwdgHandle.Init.Reload = 4095;                  // 使用最大重载值4095
    if (HAL_IWDG_Init(&IwdgHandle) != HAL_OK)       // 初始化看门狗
    {
        printf("\r\n\r\n\r\nWatchdog init failed!\r\n\r\n\r\n");
        while (1)
            ; // 进入死循环
    }

    // 初始化串口
    USART1_Init(230400);
    HAL_Delay(100);
    printf("cap buffer test\r\n");

    test_flash();

    // Flash_Write(FLASH_COE_ADDR, 24, (uint32_t *)init_coe_buffer);

    // memset(f_flash_buffer, 0, sizeof(f_flash_buffer));

    // Flash_Read(FLASH_COE_ADDR, sizeof(uint32_t) * 24, (uint32_t *)f_flash_buffer);
    while (1)
    {
    }
}

#endif

void init_cali_71_01(void)
{
    memset(UDP_71, 0, CAILI_FB_LEN_BYTES);
    UDP_71[0] = 0xFF;
    UDP_71[1] = 0xFF;
    UDP_71[2] = 0x06;
    UDP_71[3] = 0x09;

    UDP_71[6] = 0x00;
    UDP_71[7] = 0x16;

    UDP_71[8] = 0x33;
    UDP_71[9] = 0x30;
    UDP_71[10] = 0x06;
    UDP_71[11] = 0x66;

    UDP_71[12] = 0x12;
    UDP_71[13] = 0x34;
    UDP_71[14] = 0x56;
    UDP_71[15] = 0x78;

    UDP_71[16] = 0x00;
    UDP_71[17] = 0x72;

    UDP_71[18] = 0x00;
    UDP_71[19] = 0x00;

    UDP_71[20] = 0x00;
    UDP_71[21] = 0x01;
}

int main(void)
{
    // HAL库初始化
    HAL_Init();

    // 系统时钟初始化
    System_Clock_Config_HSI_24Mhz();

    // 看门狗初始化
    IwdgHandle.Instance = IWDG;                     // 独立看门狗的基地址
    IwdgHandle.Init.Prescaler = IWDG_PRESCALER_256; // 使用最大分频系数256
    IwdgHandle.Init.Reload = 4095;                  // 使用最大重载值4095
    if (HAL_IWDG_Init(&IwdgHandle) != HAL_OK)       // 初始化看门狗
    {
        // printf("\r\n\r\n\r\nWatchdog init failed!\r\n\r\n\r\n");
        while (1)
            ; // 进入死循环
    }

    // 初始化串口
    USART1_Init(230400);

    // app_read_data();
    // Flash_Read(FLASH_USER_START_ADDR, sizeof(uint32_t) * 6, (uint32_t *)f_flash_buffer);
    // Flash_Read(FLASH_USER_START_ADDR, sizeof(uint32_t) * 16, f_flash_buffer);

    HAL_Delay(100);
    // printf("status test\r\n");
    // LED初始化
    APP_LEDInit();
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);

    // 锐盟复位
    RM1002_RST_Init();

    // 锐盟初始化
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); // RM0_RST
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET); // RM1_RST
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET); // RM2_RST
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET); // RM3_RST
    HAL_Delay(100);

    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET); // RM3
    RM1002B_X = DEFAULE_I2C_ADDR_3;                     // RM3
    rm1002_init(RM1002B_X);

    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); // RM2
    RM1002B_X = DEFAULE_I2C_ADDR_2;                     // RM2
    rm1002_init(RM1002B_X);

    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET); // RM1
    RM1002B_X = DEFAULE_I2C_ADDR_1;                     // RM1
    rm1002_init(RM1002B_X);

    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET); // RM0
    RM1002B_X = DEFAULE_I2C_ADDR_0;                     // RM0
    rm1002_init(RM1002B_X);

    // 定时器初始化
    APP_TimConfig();

    uint16_t Cap_Frame_Num = 0; // 帧序列号
    uint8_t i = 0;              // 传感器通道
    uint8_t s = 0;

    // 灯亮
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);

    // test_flash();
    // 读取一次flash
    Flash_Read(FLASH_USER_START_ADDR, sizeof(uint32_t) * FF_FLASH_BUF_LEN, (uint32_t *)f_flash_buffer);

    while (1)
    {
        // 检查是否超时（程序异常）
        if (hour_timeout_flag)
        {
            // printf("System not responding for one hour, watchdog reset!\r\n");
            HAL_NVIC_SystemReset();
        }

        // 定期刷新看门狗
        if (HAL_IWDG_Refresh(&IwdgHandle) != HAL_OK)
        {
            // printf("Watchdog refresh failed!\r\n");
            while (1)
                ; // 如果刷新失败，进入死循环
        }

        if (G_USART1_RX_Flag)
        {
            process_received_data(); // 处理接收到的数据
            G_USART1_RX_Flag = 0;
        }

        // 根据上位机数据发送
        if (G_setFlag == 0x01) // 电脑输出
        {
            /* 每隔10ms，采集一次 */
            if (t_10ms_Flag == 1)
            {
                t_10ms_Flag = 0;
                const uint8_t addr_list[] = {
                    DEFAULE_I2C_ADDR_0,
                    DEFAULE_I2C_ADDR_1,
                    DEFAULE_I2C_ADDR_2,
                    DEFAULE_I2C_ADDR_3};

                // 计算电容
                for (int j = 0; j < 4; j++)
                {
                    RM1002B_X = addr_list[j];
                    c_read_value = rm1002_debug_func(RM1002B_X, cxxx0, cxxx1, cxxx2, cxxx3);
                    for (i = 0; i < 4; i++)
                    {
                        c_value[i + j * 4] = c_read_value[i];
                    }
                }
                G_Printf_Flag = 1;
            }
            if (G_Printf_Flag == 1) // 11ms
            {
                // printf("c0:%f, c1:%f, c2:%f, c3:%f, c4:%f, c5:%f, c6:%f, c7:%f, c8:%f, c9:%f, c10:%f, c11:%f, c12:%f, c13:%f, c14:%f, c15:%f\r\n",
                // c_value[0], c_value[1], c_value[2], c_value[3], c_value[4], c_value[5], c_value[6], c_value[7], c_value[8], c_value[9], c_value[10], c_value[11], c_value[12], c_value[13], c_value[14], c_value[15]);
                G_Printf_Flag = 0;
            }
        }
        else if (G_setFlag == 0x0F) // 赛感协议发送数据
        {
            /* 每隔10ms，采集一次 */
            if (t_10ms_Flag == 1)
            {
                // printf("t_10ms_Flag\r\n");
                t_10ms_Flag = 0;         // 标志位置零
                MCU_Status = 0x01;       // 设置状态为1
                if (send_once_flag == 1) // 只保存一次状态
                {
                    Flash_Write_Status(FLASH_STATUS_ADDR, MCU_Status); // 保存状态到Flash
                    MCU_Status = Flash_Read_Status(FLASH_STATUS_ADDR);
                    // printf("\r\n\r\n\r\nsave status:0x%02x\r\n\r\n\r\n", MCU_Status);
                    HAL_Delay(100);
                    send_once_flag = 0;
                }

                float update_read_value[16] = {0}; // 滑动平均后的数
                float avg_read_value[16] = {0};    // 归一化后的数
                // 读取四个RM地址
                read_and_store_values(DEFAULE_I2C_ADDR_0, 0);
                read_and_store_values(DEFAULE_I2C_ADDR_1, 4);
                read_and_store_values(DEFAULE_I2C_ADDR_2, 8);
                read_and_store_values(DEFAULE_I2C_ADDR_3, 12);

                // 设置帧号
                UDP_11[4] = (Cap_Frame_Num >> 8);
                UDP_11[5] = (Cap_Frame_Num & 0xff);
                UDP_11[17] = 0x12;
                // 传感器数量为6个
                UDP_11[19] = 0x06;

                // 滑动平均滤波
                for (s = 0; s < 16; s++)
                {
                    update_read_value[s] = averageFilter(c_value[s], s);
                }

                // /* 4*4归一补偿 */
                // avg_read_value[6] = update_read_value[6] / coe_buffer[0];
                // avg_read_value[1] = update_read_value[1] / coe_buffer[1];
                // avg_read_value[7] = update_read_value[7] / coe_buffer[2];
                // avg_read_value[0] = update_read_value[0] / coe_buffer[3];
                // avg_read_value[5] = update_read_value[5] / coe_buffer[4];
                // avg_read_value[2] = update_read_value[2] / coe_buffer[5];

                avg_read_value[6] = update_read_value[6] / f_flash_buffer[0];
                avg_read_value[1] = update_read_value[1] / f_flash_buffer[1];
                avg_read_value[7] = update_read_value[7] / f_flash_buffer[2];
                avg_read_value[0] = update_read_value[0] / f_flash_buffer[3];
                avg_read_value[5] = update_read_value[5] / f_flash_buffer[4];
                avg_read_value[2] = update_read_value[2] / f_flash_buffer[5];

                // 处理采集到的16个电容值 --- 智元鞋垫，6压力，2温度
                process_value(avg_read_value[6], UDP_11, 20); /* 0 */
                process_value(avg_read_value[1], UDP_11, 26); /* 1 */
                process_value(avg_read_value[7], UDP_11, 32); /* 2 */
                process_value(avg_read_value[0], UDP_11, 38); /* 3 */
                process_value(avg_read_value[5], UDP_11, 44); /* 4 */
                process_value(avg_read_value[2], UDP_11, 50); /* 5 */

                // 发送数据
                // HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_11, sizeof(UDP_11), 10); // 串口发送数据
                HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_11, ZHIYUAN_FOOT_SENSOR_DATA_LEN, 10); // 串口发送数据

                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ; // 等待发送完成
                Cap_Frame_Num++;

                // 如果超出范围则重置
                if (Cap_Frame_Num >= 65534) // 使用更精确的边界值
                {
                    Cap_Frame_Num = 0;
                    // 添加同步标记
                    UDP_11[4] = 0;
                    UDP_11[5] = 0;
                }
            }
        }
        else if (G_setFlag == 0xF0) // 通道0校准---56pF
        {
            calibrate_channel(0);
        }
        else if (G_setFlag == 0xF1) // 通道1校准
        {
            calibrate_channel(1);
        }
        else if (G_setFlag == 0xF2) // 通道2校准
        {
            calibrate_channel(2);
        }
        else if (G_setFlag == 0xF3) // 通道3校准
        {
            calibrate_channel(3);
        }

        if (UART_RX_CMD)
        {
            Generic_Reply[5] = 0x01;  // 设置帧号
            Generic_Reply[7] = 0x2a;  // 设置帧长
            Generic_Reply[17] = 0x02; // 设置回复
            if (UART_RX_CMD == 0x07)
            {
                HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ; // 等待发送完成
            }
            else if (UART_RX_CMD == 0x09)
            {
                HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ; // 等待发送完成
            }
            UART_RX_CMD = 0;
        }
        else if (UART_RX_CMD_1)
        {
            UART_RX_CMD_1 = 0;        // 清除标志位
            Generic_Reply[5] = 0x01;  // 设置帧号
            Generic_Reply[7] = 0x2a;  // 设置帧长
            Generic_Reply[17] = 0x02; // 设置回复

            HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_3)
        {
            UART_RX_CMD_3 = 0;

            // 设置帧号
            UDP_11[4] = (Cap_Frame_Num >> 8);
            UDP_11[5] = (Cap_Frame_Num & 0xff);
            UDP_11[17] = 0x04;

            HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_11, sizeof(UDP_11), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_5)
        {
            UART_RX_CMD_5 = 0;
            Generic_Reply[5] = 0x06;  // 设置帧号
            Generic_Reply[7] = 0x2a;  // 设置帧长
            Generic_Reply[17] = 0x06; // 设置回复

            HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_11)
        {
            // 一直发数据---flag
            G_setFlag = 0x0F;
            UART_RX_CMD_11 = 0;
        }
        else if (UART_RX_CMD_13) // 停止发送数据
        {
            // 停止发送数据
            G_setFlag = 0x00;
            MCU_Status = 0x00;                                 // 设置状态为0
            Flash_Write_Status(FLASH_STATUS_ADDR, MCU_Status); // 保存状态到Flash
            MCU_Status = Flash_Read_Status(FLASH_STATUS_ADDR);
            // printf("\r\n\r\n\r\nstop status:0x%02x\r\n\r\n\r\n", MCU_Status);
            UART_RX_CMD_13 = 0;
            Generic_Reply[5] = 0x0E;  // 设置帧号
            Generic_Reply[7] = 0x2a;  // 设置帧长
            Generic_Reply[17] = 0x14; // 设置回复

            // 回复指令
            HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_15)
        {
            UART_RX_CMD_15 = 0;
            HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_15, sizeof(UDP_15), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_71)
        {
            UART_RX_CMD_71 = 0; // 清除标志位

            // 解析通道号 (20-21位)
            uint16_t channel = ((uint16_t)G_USART1_RX_Buffer[20] << 8) | (uint16_t)G_USART1_RX_Buffer[21];

            // 解析操作类型 (22-23位)
            uint16_t operation = ((uint16_t)G_USART1_RX_Buffer[22] << 8) | (uint16_t)G_USART1_RX_Buffer[23];

            // 解析数值 (24-29位)
            uint32_t int_part = ((uint32_t)G_USART1_RX_Buffer[24] << 16) |
                                ((uint32_t)G_USART1_RX_Buffer[25] << 8) |
                                G_USART1_RX_Buffer[26];

            uint32_t dec_part = ((uint32_t)G_USART1_RX_Buffer[27] << 16) |
                                ((uint32_t)G_USART1_RX_Buffer[28] << 8) |
                                G_USART1_RX_Buffer[29];

            float value = (float)int_part + (float)dec_part / 1000000.0f;

            // 通道映射表 - 上位机发送的通道号作为索引,得到实际操作的通道号

            // uint8_t mapped_channel = 0;

            switch (operation)
            {
            case 0x0000: // 写入单个通道系数
                // 根据通道号和数值，修改flash，根据映射表修改
                // mapped_channel = channel_map[channel];

                // 暂时注释掉
                // coe_buffer[channel] = value;
                f_flash_buffer[channel] = value;
                // memcpy(&f_flash_buffer[channel], G_USART1_RX_Buffer[24], 6);
                // printf("int_part:%d, dec_part:%d\r\n", int_part, dec_part);
                // printf("channel:%d, value:%f\r\n", channel, value);

                break;

            case 0x0001: // 读取单个通道系数
            {

                init_cali_71_01();
                // 状态位
                UDP_71[18] = 0x00;
                UDP_71[19] = 0x01;

                // 通道
                UDP_71[20] = channel >> 8;
                UDP_71[21] = channel & 0xff;

                // type类型
                UDP_71[22] = 0x00;
                UDP_71[23] = 0x01;

                // 先读取flash
                // Flash_Read(FLASH_COE_ADDR, sizeof(coe_buffer), (uint32_t *)coe_buffer);
                // Flash_Read(FLASH_COE_ADDR, sizeof(uint32_t) * 24, (uint32_t *)f_flash_buffer);
                // Flash_Read(FLASH_COE_ADDR, sizeof(uint32_t) * 24, (uint32_t *)f_flash_buffer);
                // app_read_data();
                // Flash_Read(FLASH_COE_ADDR, sizeof(coe_buffer), (uint32_t *)coe_buffer);
                HAL_Delay(100);

                // 根据映射表，找到对应的通道
                // mapped_channel  = channel_map[channel];

                // 将对应通道的系数转换为6字节数据
                // printf("coe_buffer[%d]:%f\r\n", index, coe_buffer[index]);
                // printf("ch0 :%f\n", f_flash_buffer[channel]);
                process_value(f_flash_buffer[channel], UDP_71, 24);

                // UDP_71[24] = 0x11;
                // UDP_71[25] = 0x11;
                // UDP_71[26] = 0x11;
                // UDP_71[27] = 0x11;
                // UDP_71[28] = 0x11;
                // UDP_71[29] = 0x11;

                // 发送回复
                HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_71, CAILI_FB_LEN_BYTES, 20); // 串口发送数据
                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ; // 等待发送完成

                break;
            }

            case 0x0002: // 读取所有通道系数
            {
                UDP_11[17] = 0x72; // 修改命令字为0x72

                // 先读取flash
                Flash_Read(FLASH_USER_START_ADDR, sizeof(float) * FF_FLASH_BUF_LEN, (uint32_t *)f_flash_buffer);

                // 处理采集到的16个电容值 --- 指尖的对应位置
                process_value(f_flash_buffer[12], UDP_11, 20); /* 0  */
                process_value(f_flash_buffer[9], UDP_11, 26);  /* 1  */
                process_value(f_flash_buffer[6], UDP_11, 32);  /* 2  */
                process_value(f_flash_buffer[3], UDP_11, 38);  /* 3  */
                process_value(f_flash_buffer[13], UDP_11, 44); /* 4  */
                process_value(f_flash_buffer[8], UDP_11, 50);  /* 5  */
                process_value(f_flash_buffer[7], UDP_11, 56);  /* 6  */
                process_value(f_flash_buffer[2], UDP_11, 62);  /* 7  */
                process_value(f_flash_buffer[14], UDP_11, 68); /* 8  */
                process_value(f_flash_buffer[10], UDP_11, 74); /* 9  */
                process_value(f_flash_buffer[5], UDP_11, 80);  /* 10 */
                process_value(f_flash_buffer[1], UDP_11, 86);  /* 11 */
                process_value(f_flash_buffer[15], UDP_11, 92); /* 12 */
                process_value(f_flash_buffer[11], UDP_11, 98); /* 13 */
                process_value(f_flash_buffer[4], UDP_11, 104); /* 14 */
                process_value(f_flash_buffer[0], UDP_11, 110); /* 15 */

                // 状态位
                UDP_11[18] = 0x00;
                UDP_11[19] = 0x01;

                // 发送数据
                HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_11, sizeof(UDP_11), 10);
                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ;

                UDP_11[17] = 0x12; // 恢复命令字为0x12

                break;
            }

            case 0x0003: // 保存所有通道系数
            {

                // 临时停止数据发送
                uint8_t original_flag = G_setFlag;
                G_setFlag = 0x00;

                // 等待最后一帧发送完成
                HAL_Delay(20);

                // 写入Flash
                Flash_Write(FLASH_USER_START_ADDR, sizeof(float) * FF_FLASH_BUF_LEN, (uint32_t *)f_flash_buffer);
                HAL_Delay(100);
                // 回读
                Flash_Read(FLASH_USER_START_ADDR, sizeof(float) * FF_FLASH_BUF_LEN, (uint32_t *)f_flash_buffer);

                // 恢复原来的发送状态
                G_setFlag = original_flag;

                // 重置帧号和帧头
                Cap_Frame_Num = 0;
                // UDP_11[4] = 0;
                // UDP_11[5] = 0;

                break;
            }
            }
        }
    }
}

#if 0
int main__(void)
{

    // HAL库初始化
    HAL_Init();

    // 系统时钟初始化
    System_Clock_Config_HSI_24Mhz();

    // 看门狗初始化
    IwdgHandle.Instance = IWDG;                     // 独立看门狗的基地址
    IwdgHandle.Init.Prescaler = IWDG_PRESCALER_256; // 使用最大分频系数256
    IwdgHandle.Init.Reload = 4095;                  // 使用最大重载值4095
    if (HAL_IWDG_Init(&IwdgHandle) != HAL_OK)       // 初始化看门狗
    {
        printf("\r\n\r\n\r\nWatchdog init failed!\r\n\r\n\r\n");
        while (1)
            ; // 进入死循环
    }

    // 初始化串口
    USART1_Init(230400);
    HAL_Delay(100);
    printf("cap buffer test\r\n");
    Flash_Write(FLASH_CAP_ADDR, sizeof(cap_buffer), (uint32_t *)cap_buffer); // 写入寄生电容
    HAL_Delay(100);
    Flash_Read(FLASH_CAP_ADDR, sizeof(cap_buffer), (uint32_t *)cap_buffer);
    HAL_Delay(100);
    printf("coe buffer test\r\n");
#if FLEX_FLAG
    Flash_Write(FLASH_COE_ADDR, sizeof(coe_buffer), (uint32_t *)coe_buffer); // 写入归一化系数
    HAL_Delay(100);

#endif
    // Flash_Read(FLASH_COE_ADDR, sizeof(coe_buffer), (uint32_t *)&coe_buffer[0]);

    // Flash_Read(FLASH_USER_START_ADDR, sizeof(uint32_t) * 16, flash_buffer);

    HAL_Delay(100);
    printf("status test\r\n");
#if FLEX_FLAG
    Flash_Write_Status(FLASH_STATUS_ADDR, MCU_Status); // 保存状态到Flash
    HAL_Delay(100);

#endif
    MCU_Status = Flash_Read_Status(FLASH_STATUS_ADDR);
    printf("MCU_Status:0x%02x\r\n", MCU_Status);
    if (MCU_Status == 0x01) // 表示正常情况下异常跑飞，看门狗重启后继续发送数据
    {
        UART_RX_CMD_11 = 0x01;
    }

#if FLEX_FLAG
    // AT指令设置命名
    AT_Program();
#endif

    // LED初始化
    APP_LEDInit();
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);

    // 锐盟复位
    RM1002_RST_Init();

    // 锐盟初始化
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); // RM0_RST
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET); // RM1_RST
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET); // RM2_RST
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET); // RM3_RST
    HAL_Delay(100);

    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET); // RM3
    RM1002B_X = DEFAULE_I2C_ADDR_3;                     // RM3
    rm1002_init(RM1002B_X);

    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); // RM2
    RM1002B_X = DEFAULE_I2C_ADDR_2;                     // RM2
    rm1002_init(RM1002B_X);

    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET); // RM1
    RM1002B_X = DEFAULE_I2C_ADDR_1;                     // RM1
    rm1002_init(RM1002B_X);

    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET); // RM0
    RM1002B_X = DEFAULE_I2C_ADDR_0;                     // RM0
    rm1002_init(RM1002B_X);

    // 定时器初始化
    APP_TimConfig();

    uint16_t Cap_Frame_Num = 0; // 帧序列号
    uint8_t i = 0;              // 传感器通道
    uint8_t s = 0;

    // 灯亮
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);
    while (1)
    {
        // 检查是否超时（程序异常）
        if (hour_timeout_flag)
        {
            printf("System not responding for one hour, watchdog reset!\r\n");
            HAL_NVIC_SystemReset();
        }

        // 定期刷新看门狗
        if (HAL_IWDG_Refresh(&IwdgHandle) != HAL_OK)
        {
            printf("Watchdog refresh failed!\r\n");
            while (1)
                ; // 如果刷新失败，进入死循环
        }

        if (G_USART1_RX_Flag)
        {
            process_received_data(); // 处理接收到的数据
            G_USART1_RX_Flag = 0;
        }

        // 根据上位机数据发送
        if (G_setFlag == 0x01) // 电脑输出
        {
            /* 每隔10ms，采集一次 */
            if (t_10ms_Flag == 1)
            {
                t_10ms_Flag = 0;
                const uint8_t addr_list[] = {
                    DEFAULE_I2C_ADDR_0,
                    DEFAULE_I2C_ADDR_1,
                    DEFAULE_I2C_ADDR_2,
                    DEFAULE_I2C_ADDR_3};

                // 计算电容
                for (int j = 0; j < 4; j++)
                {
                    RM1002B_X = addr_list[j];
                    c_read_value = rm1002_debug_func(RM1002B_X, cxxx0, cxxx1, cxxx2, cxxx3);
                    for (i = 0; i < 4; i++)
                    {
                        c_value[i + j * 4] = c_read_value[i];
                    }
                }
                G_Printf_Flag = 1;
            }
            if (G_Printf_Flag == 1) // 11ms
            {
                // printf("c0:%f, c1:%f, c2:%f, c3:%f, c4:%f, c5:%f, c6:%f, c7:%f, c8:%f, c9:%f, c10:%f, c11:%f, c12:%f, c13:%f, c14:%f, c15:%f\r\n",
                // c_value[0], c_value[1], c_value[2], c_value[3], c_value[4], c_value[5], c_value[6], c_value[7], c_value[8], c_value[9], c_value[10], c_value[11], c_value[12], c_value[13], c_value[14], c_value[15]);
                G_Printf_Flag = 0;
            }
        }
        else if (G_setFlag == 0x0F) // 赛感协议发送数据
        {
            /* 每隔10ms，采集一次 */
            if (t_10ms_Flag == 1)
            {
                t_10ms_Flag = 0;         // 标志位置零
                MCU_Status = 0x01;       // 设置状态为1
                if (send_once_flag == 1) // 只保存一次状态
                {
                    Flash_Write_Status(FLASH_STATUS_ADDR, MCU_Status); // 保存状态到Flash
                    MCU_Status = Flash_Read_Status(FLASH_STATUS_ADDR);
                    printf("\r\n\r\n\r\nsave status:0x%02x\r\n\r\n\r\n", MCU_Status);
                    HAL_Delay(100);
                    send_once_flag = 0;
                }

                float update_read_value[16] = {0}; // 滑动平均后的数
                float avg_read_value[16] = {0};    // 归一化后的数
                // 读取四个RM地址
                read_and_store_values(DEFAULE_I2C_ADDR_0, 0);
                read_and_store_values(DEFAULE_I2C_ADDR_1, 4);
                read_and_store_values(DEFAULE_I2C_ADDR_2, 8);
                read_and_store_values(DEFAULE_I2C_ADDR_3, 12);

                // 设置帧号
                UDP_11[4] = (Cap_Frame_Num >> 8);
                UDP_11[5] = (Cap_Frame_Num & 0xff);
                UDP_11[17] = 0x12;

                // 滑动平均滤波
                for (s = 0; s < 16; s++)
                {
                    update_read_value[s] = averageFilter(c_value[s], s);
                }

                // /* 4*4归一补偿 */
                avg_read_value[6] = update_read_value[6] / f_flash_buffer[0];
                avg_read_value[1] = update_read_value[1] / f_flash_buffer[1];
                avg_read_value[7] = update_read_value[7] / f_flash_buffer[2];
                avg_read_value[0] = update_read_value[0] / f_flash_buffer[3];
                avg_read_value[5] = update_read_value[5] / f_flash_buffer[4];
                avg_read_value[2] = update_read_value[2] / f_flash_buffer[5];

                // 处理采集到的16个电容值 --- 智元鞋垫，6压力，2温度
                process_value(avg_read_value[6], UDP_11, 20); /* 0 */
                process_value(avg_read_value[1], UDP_11, 26); /* 1 */
                process_value(avg_read_value[7], UDP_11, 32); /* 2 */
                process_value(avg_read_value[0], UDP_11, 38); /* 3 */
                process_value(avg_read_value[5], UDP_11, 44); /* 4 */
                process_value(avg_read_value[2], UDP_11, 50); /* 5 */

                // 发送数据
                HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_11, sizeof(UDP_11), 10); // 串口发送数据
                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ; // 等待发送完成
                Cap_Frame_Num++;

                // 如果超出范围则重置
                if (Cap_Frame_Num >= 65534) // 使用更精确的边界值
                {
                    Cap_Frame_Num = 0;
                    // 添加同步标记
                    UDP_11[4] = 0;
                    UDP_11[5] = 0;
                }
            }
        }
        else if (G_setFlag == 0xF0) // 通道0校准---56pF
        {
            calibrate_channel(0);
        }
        else if (G_setFlag == 0xF1) // 通道1校准
        {
            calibrate_channel(1);
        }
        else if (G_setFlag == 0xF2) // 通道2校准
        {
            calibrate_channel(2);
        }
        else if (G_setFlag == 0xF3) // 通道3校准
        {
            calibrate_channel(3);
        }

        if (UART_RX_CMD)
        {
            Generic_Reply[5] = 0x01;  // 设置帧号
            Generic_Reply[7] = 0x2a;  // 设置帧长
            Generic_Reply[17] = 0x02; // 设置回复
            if (UART_RX_CMD == 0x07)
            {
                HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ; // 等待发送完成
            }
            else if (UART_RX_CMD == 0x09)
            {
                HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ; // 等待发送完成
            }
            UART_RX_CMD = 0;
        }
        else if (UART_RX_CMD_1)
        {
            UART_RX_CMD_1 = 0;        // 清除标志位
            Generic_Reply[5] = 0x01;  // 设置帧号
            Generic_Reply[7] = 0x2a;  // 设置帧长
            Generic_Reply[17] = 0x02; // 设置回复

            HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_3)
        {
            UART_RX_CMD_3 = 0;

            // 设置帧号
            UDP_11[4] = (Cap_Frame_Num >> 8);
            UDP_11[5] = (Cap_Frame_Num & 0xff);
            UDP_11[17] = 0x04;

            HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_11, sizeof(UDP_11), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_5)
        {
            UART_RX_CMD_5 = 0;
            Generic_Reply[5] = 0x06;  // 设置帧号
            Generic_Reply[7] = 0x2a;  // 设置帧长
            Generic_Reply[17] = 0x06; // 设置回复

            HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_11)
        {
            // 一直发数据---flag
            G_setFlag = 0x0F;
            UART_RX_CMD_11 = 0;
        }
        else if (UART_RX_CMD_13) // 停止发送数据
        {
            // 停止发送数据
            G_setFlag = 0x00;
            MCU_Status = 0x00;                                 // 设置状态为0
            Flash_Write_Status(FLASH_STATUS_ADDR, MCU_Status); // 保存状态到Flash
            MCU_Status = Flash_Read_Status(FLASH_STATUS_ADDR);
            printf("\r\n\r\n\r\nstop status:0x%02x\r\n\r\n\r\n", MCU_Status);
            UART_RX_CMD_13 = 0;
            Generic_Reply[5] = 0x0E;  // 设置帧号
            Generic_Reply[7] = 0x2a;  // 设置帧长
            Generic_Reply[17] = 0x14; // 设置回复

            // 回复指令
            HAL_UART_Transmit(&UartHandle, (uint8_t *)Generic_Reply, sizeof(Generic_Reply), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_15)
        {
            UART_RX_CMD_15 = 0;
            HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_15, sizeof(UDP_15), 20); // 串口发送数据
            while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                ; // 等待发送完成
        }
        else if (UART_RX_CMD_71)
        {
            UART_RX_CMD_71 = 0; // 清除标志位

            // 解析通道号 (20-21位)
            uint16_t channel = ((uint16_t)G_USART1_RX_Buffer[20] << 8) | (uint16_t)G_USART1_RX_Buffer[21];

            // 解析操作类型 (22-23位)
            uint16_t operation = ((uint16_t)G_USART1_RX_Buffer[22] << 8) | (uint16_t)G_USART1_RX_Buffer[23];

            // 解析数值 (24-29位)
            uint32_t int_part = ((uint32_t)G_USART1_RX_Buffer[24] << 16) |
                                ((uint32_t)G_USART1_RX_Buffer[25] << 8) |
                                G_USART1_RX_Buffer[26];

            uint32_t dec_part = ((uint32_t)G_USART1_RX_Buffer[27] << 16) |
                                ((uint32_t)G_USART1_RX_Buffer[28] << 8) |
                                G_USART1_RX_Buffer[29];

            float value = (float)int_part + (float)dec_part / 1000000.0f;

            // 通道映射表 - 上位机发送的通道号作为索引,得到实际操作的通道号

            // uint8_t mapped_channel = 0;

            switch (operation)
            {
            case 0x0000: // 写入单个通道系数
                // 根据通道号和数值，修改flash，根据映射表修改
                // mapped_channel = channel_map[channel];
                // 这里先注释
                // coe_buffer[channel] = value;

                break;

            case 0x0001: // 读取单个通道系数
            {
                // 状态位
                UDP_71[18] = 0x00;
                UDP_71[19] = 0x01;

                // 通道
                UDP_71[20] = channel >> 8;
                UDP_71[21] = channel & 0xff;

                // type类型
                UDP_71[22] = 0x00;
                UDP_71[23] = 0x01;

                // 先读取flash
                // Flash_Read(FLASH_COE_ADDR, sizeof(coe_buffer), (uint32_t *)coe_buffer);
                // Flash_Read(FLASH_COE_ADDR, sizeof(uint32_t) * 24, (uint32_t *)f_flash_buffer);
                // Flash_Read(FLASH_COE_ADDR, sizeof(uint32_t) * 24, (uint32_t *)f_flash_buffer);
                // app_read_data();
                Flash_Read(FLASH_USER_START_ADDR, sizeof(uint32_t) * 6, (uint32_t *)f_flash_buffer);
                // Flash_Read(FLASH_COE_ADDR, sizeof(coe_buffer), (uint32_t *)coe_buffer);
                // HAL_Delay(100);

                // 根据映射表，找到对应的通道
                // mapped_channel  = channel_map[channel];

                // 将对应通道的系数转换为6字节数据
                // printf("coe_buffer[%d]:%f\r\n", index, coe_buffer[index]);
                process_value(f_flash_buffer[channel], UDP_71, 24);

                // UDP_71[24] = 0x11;
                // UDP_71[25] = 0x11;
                // UDP_71[26] = 0x11;
                // UDP_71[27] = 0x11;
                // UDP_71[28] = 0x11;
                // UDP_71[29] = 0x11;

                // 发送回复
                HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_71, sizeof(UDP_71), 20); // 串口发送数据
                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ; // 等待发送完成

                break;
            }

            case 0x0002: // 读取所有通道系数
            {
#if 0
                UDP_11[17] = 0x72; // 修改命令字为0x72

                // 先读取flash
                Flash_Read(FLASH_USER_START_ADDR, sizeof(coe_buffer), (uint32_t *)coe_buffer);

                // 处理采集到的16个电容值 --- 指尖的对应位置
                process_value(coe_buffer[12], UDP_11, 20); /* 0  */
                process_value(coe_buffer[9], UDP_11, 26);  /* 1  */
                process_value(coe_buffer[6], UDP_11, 32);  /* 2  */
                process_value(coe_buffer[3], UDP_11, 38);  /* 3  */
                process_value(coe_buffer[13], UDP_11, 44); /* 4  */
                process_value(coe_buffer[8], UDP_11, 50);  /* 5  */
                process_value(coe_buffer[7], UDP_11, 56);  /* 6  */
                process_value(coe_buffer[2], UDP_11, 62);  /* 7  */
                process_value(coe_buffer[14], UDP_11, 68); /* 8  */
                process_value(coe_buffer[10], UDP_11, 74); /* 9  */
                process_value(coe_buffer[5], UDP_11, 80);  /* 10 */
                process_value(coe_buffer[1], UDP_11, 86);  /* 11 */
                process_value(coe_buffer[15], UDP_11, 92); /* 12 */
                process_value(coe_buffer[11], UDP_11, 98); /* 13 */
                process_value(coe_buffer[4], UDP_11, 104); /* 14 */
                process_value(coe_buffer[0], UDP_11, 110); /* 15 */

                // 发送数据
                HAL_UART_Transmit(&UartHandle, (uint8_t *)UDP_11, sizeof(UDP_11), 10);
                while (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_TC) == RESET)
                    ;

                UDP_11[17] = 0x12; // 恢复命令字为0x12

#endif
                break;
            }

            case 0x0003: // 保存所有通道系数
            {
#if 0
                // 临时停止数据发送
                uint8_t original_flag = G_setFlag;
                G_setFlag = 0x00;

                // 等待最后一帧发送完成
                HAL_Delay(20);

                printf("\r\n\r\n\r\nSaving coefficients...\r\n");
                Flash_Write(FLASH_USER_START_ADDR, sizeof(coe_buffer), (uint32_t *)coe_buffer);
                HAL_Delay(100);
                Flash_Read(FLASH_USER_START_ADDR, sizeof(coe_buffer), (uint32_t *)coe_buffer);
                printf("Coefficients saved.\r\n\r\n\r\n");

                // 恢复原来的发送状态
                G_setFlag = original_flag;

                // 重置帧号和帧头
                Cap_Frame_Num = 0;
                UDP_11[4] = 0;
                UDP_11[5] = 0;
#endif
                break;
            }
            }
        }
    }
}
#endif